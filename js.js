// Generated by CoffeeScript 1.2.1-pre
(function() {
  var Body, BodyDef, CircleShape, DebugDraw, DistanceJointDef, Fixture, FixtureDef, MassData, MouseJointDef, PolygonShape, Vec2, World, box_angularDampling, box_density, box_friction, box_linearDampling, box_restitution, gravity_x, gravity_y, scaleFactor, spring_damping_ratio, spring_frequency, spring_length;

  Vec2 = Box2D.Common.Math.b2Vec2;

  BodyDef = Box2D.Dynamics.b2BodyDef;

  Body = Box2D.Dynamics.b2Body;

  FixtureDef = Box2D.Dynamics.b2FixtureDef;

  Fixture = Box2D.Dynamics.b2Fixture;

  World = Box2D.Dynamics.b2World;

  MassData = Box2D.Collision.Shapes.b2MassData;

  PolygonShape = Box2D.Collision.Shapes.b2PolygonShape;

  CircleShape = Box2D.Collision.Shapes.b2CircleShape;

  DebugDraw = Box2D.Dynamics.b2DebugDraw;

  DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef;

  MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef;

  scaleFactor = 30;

  box_restitution = .1;

  box_density = 2;

  box_friction = .9;

  box_linearDampling = .5;

  box_angularDampling = 2;

  spring_frequency = 2;

  spring_damping_ratio = .2;

  spring_length = 10;

  gravity_x = 0;

  gravity_y = 10;

  window.onload = function() {
    var animloop, boxLayer, boxes, debugLayer, drawer, lastTime, lineLayer, linkMaking, makeBox, makeDrawer, makeLink, makeWall, makeWorld, mouse, position, render, selection, stage, started, velocity, wh, world, ww;
    ww = window.innerWidth;
    wh = window.innerHeight;
    mouse = {
      x: 0,
      y: 0,
      joint: null
    };
    boxes = [];
    linkMaking = false;
    started = false;
    selection = [];
    window.selection = selection;
    stage = new Kinetic.Stage({
      container: "container",
      width: ww,
      height: wh
    });
    boxLayer = new Kinetic.Layer();
    lineLayer = new Kinetic.Layer();
    debugLayer = new Kinetic.Layer();
    makeWorld = function() {
      return new World(new Vec2(gravity_x, gravity_y), true);
    };
    makeDrawer = function(world) {
      var drawer;
      drawer = new DebugDraw();
      drawer.SetSprite(debugLayer.context);
      drawer.SetDrawScale(scaleFactor);
      drawer.SetFillAlpha(.5);
      drawer.SetLineThickness(1.0);
      drawer.SetFlags(DebugDraw.e_shapeBit | DebugDraw.e_jointBit);
      world.SetDebugDraw(drawer);
      return drawer;
    };
    makeWall = function(world) {
      var bh, bw, wall, wallBd, wallLeft, wallRight, _wallBottom, _wallTop;
      wall = new PolygonShape();
      wallBd = new BodyDef();
      bw = ww / 30;
      bh = wh / 30;
      wallBd.position.Set(.25, 0);
      wall.SetAsBox(.25, bh);
      wallLeft = world.CreateBody(wallBd);
      wallLeft.CreateFixture2(wall);
      wallBd.position.Set(bw - .25, 0);
      wallRight = world.CreateBody(wallBd);
      wallRight.CreateFixture2(wall);
      wallBd.position.Set(0, .25);
      wall.SetAsBox(bw, .25);
      _wallTop = world.CreateBody(wallBd);
      _wallTop.CreateFixture2(wall);
      wallBd.position.Set(0, bh - .25);
      _wallBottom = world.CreateBody(wallBd);
      return _wallBottom.CreateFixture2(wall);
    };
    makeBox = function(world, x, y, text) {
      var bodyDef, box, fixtureDef, h, rect, shape, trans, w;
      trans = null;
      text = new Kinetic.Text({
        x: 1,
        y: 1,
        text: text,
        stroke: '#555',
        strokeWidth: 1,
        fill: '#ddd',
        fontSize: 14,
        fontFamily: 'Calibri',
        fontStyle: 'normal',
        textFill: '#555',
        padding: 10,
        align: 'center'
      });
      w = text.textWidth + 22;
      h = 150;
      rect = new Kinetic.Rect({
        x: 0,
        y: 0,
        width: w,
        height: h,
        fill: "#eee",
        stroke: "#333",
        alpha: 1,
        strokeWidth: 2,
        shadow: {
          color: "black",
          blur: 10,
          offset: [5, 5],
          alpha: 0.6
        }
      });
      box = {
        links: []
      };
      box.group = new Kinetic.Group({
        x: x + w / 2,
        y: y + h / 2,
        scale: {
          x: 1,
          y: 1
        },
        offset: [w / 2, h / 2],
        selected: false,
        select: function(add) {
          var selectedbox, _i, _len;
          if (linkMaking) {
            for (_i = 0, _len = selection.length; _i < _len; _i++) {
              selectedbox = selection[_i];
              makeLink(world, selectedbox, box);
            }
            linkMaking = false;
          }
          if (!add) {
            boxes.map(function(b) {
              return b.group.attrs.unselect();
            });
          }
          selection.push(box);
          rect.setAttrs({
            shadow: {
              color: 'blue',
              blur: 10,
              offset: [5, 5],
              alpha: 0.6
            }
          });
          box.group.attrs.selected = true;
          box.group.moveToTop();
          return boxLayer.draw();
        },
        unselect: function() {
          selection.splice(box);
          rect.setAttrs({
            shadow: {
              color: 'black',
              blur: 10,
              offset: [5, 5],
              alpha: 0.6
            }
          });
          box.group.attrs.selected = false;
          return boxLayer.draw();
        },
        rect: rect,
        text: text
      });
      box.group.add(rect);
      box.group.add(text);
      bodyDef = new BodyDef();
      bodyDef.type = Body.b2_dynamicBody;
      bodyDef.position.Set(box.group.attrs.x / scaleFactor, box.group.attrs.y / scaleFactor);
      bodyDef.angle = 0;
      bodyDef.angularDamping = box_angularDampling;
      bodyDef.linearDamping = box_linearDampling;
      box.body = world.CreateBody(bodyDef);
      box.body.w = w / (2 * scaleFactor);
      box.body.h = h / (2 * scaleFactor);
      shape = new PolygonShape.AsBox(box.body.w, box.body.h);
      fixtureDef = new FixtureDef();
      fixtureDef.restitution = box_restitution;
      fixtureDef.density = box_density;
      fixtureDef.friction = box_friction;
      fixtureDef.shape = shape;
      box.body.CreateFixture(fixtureDef);
      text.on("click", function() {
        var txt;
        txt = prompt("Enter the name", text.attrs.text);
        if (txt) {
          text.setAttrs({
            text: txt
          });
          return rect.setAttrs({
            width: text.textWidth + 20
          });
        }
      });
      box.group.on("mousedown", function(e) {
        var joint;
        if (box.group.attrs.selected) {
          box.group.attrs.unselect();
        } else {
          box.group.attrs.select(e.shiftKey);
        }
        if (!mouse.joint) {
          joint = new MouseJointDef();
          joint.bodyA = world.GetGroundBody();
          joint.bodyB = box.body;
          joint.target = new Vec2(mouse.x / scaleFactor, mouse.y / scaleFactor);
          joint.collideConnected = true;
          joint.maxForce = 300 * box.body.GetMass();
          mouse.joint = world.CreateJoint(joint);
          return box.body.SetAwake(true);
        }
      });
      box.group.attrs.moved = function() {
        var link, points, _i, _len, _ref;
        _ref = box.links;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          link = _ref[_i];
          points = link.line.getPoints();
          points[link.side].x = box.group.attrs.x;
          points[link.side].y = box.group.attrs.y;
          link.line.setPoints(points);
        }
        return lineLayer.draw();
      };
      boxLayer.add(box.group);
      boxes.push(box);
      if (started) return boxLayer.draw();
    };
    makeLink = function(world, box1, box2) {
      var line, spring;
      line = new Kinetic.Line({
        points: [box1.group.attrs.x, box1.group.attrs.y, box2.group.attrs.x, box2.group.attrs.y],
        stroke: "black",
        strokeWidth: 1.5,
        lineCap: "round",
        lineJoin: "round"
      });
      spring = new DistanceJointDef();
      spring.bodyA = box1.body;
      spring.bodyB = box2.body;
      spring.frequencyHz = spring_frequency;
      spring.dampingRatio = spring_damping_ratio;
      spring.localAnchorA = new Vec2(0, -.33);
      spring.localAnchorB = new Vec2(0, -.33);
      spring.length = spring_length;
      world.CreateJoint(spring);
      box1.links.push({
        line: line,
        spring: spring,
        side: 0
      });
      box2.links.push({
        line: line,
        spring: spring,
        side: 1
      });
      lineLayer.add(line);
      if (started) lineLayer.draw();
      return line;
    };
    stage.add(lineLayer);
    stage.add(boxLayer);
    stage.add(debugLayer);
    window.ll = lineLayer;
    window.bl = boxLayer;
    window.document.body.onmousemove = function(e) {
      mouse.x = e.clientX;
      mouse.y = e.clientY;
      if (mouse.joint) {
        return mouse.joint.SetTarget(new Vec2(mouse.x / scaleFactor, mouse.y / scaleFactor));
      }
    };
    window.document.body.onmouseup = function(e) {
      if (mouse.joint) {
        world.DestroyJoint(mouse.joint);
        return mouse.joint = null;
      }
    };
    window.onkeydown = function(e) {
      var box, _i, _j, _k, _len, _len2, _len3, _results, _results2, _results3;
      if (e.keyCode === 78) {
        return makeBox(world, mouse.x, mouse.y, 'Box #' + boxes.length);
      } else if (e.keyCode === 76) {
        if (!linkMaking) return linkMaking = true;
      } else if (e.keyCode === 83) {
        _results = [];
        for (_i = 0, _len = selection.length; _i < _len; _i++) {
          box = selection[_i];
          _results.push(box.body.SetType(Body.b2_kineticBody));
        }
        return _results;
      } else if (e.keyCode === 82) {
        _results2 = [];
        for (_j = 0, _len2 = selection.length; _j < _len2; _j++) {
          box = selection[_j];
          _results2.push(box.body.SetType(Body.b2_dynamicBody));
        }
        return _results2;
      } else if (e.keyCode === 90) {
        _results3 = [];
        for (_k = 0, _len3 = selection.length; _k < _len3; _k++) {
          box = selection[_k];
          _results3.push(box.body.SetAngle(0));
        }
        return _results3;
      } else {
        boxLayer.draw();
        return lineLayer.draw();
      }
    };
    world = makeWorld();
    drawer = makeDrawer(world);
    makeWall(world);
    makeBox(world, 100, 100, 'Box #' + boxes.length);
    makeBox(world, 400, 200, 'Box #' + boxes.length);
    makeLink(world, boxes[0], boxes[1]);
    started = true;
    boxLayer.draw();
    lineLayer.draw();
    animloop = function() {
      (window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame)(animloop);
      return render(drawer);
    };
    lastTime = new Date().getTime();
    velocity = 300;
    position = 200;
    render = function() {
      var box, delta, pos, time, _i, _len;
      time = new Date().getTime();
      delta = (time - lastTime) / 1000;
      lastTime = time;
      world.Step(delta, delta * velocity, delta * position);
      for (_i = 0, _len = boxes.length; _i < _len; _i++) {
        box = boxes[_i];
        pos = box.body.GetPosition();
        box.group.setX(pos.x * scaleFactor);
        box.group.setY(pos.y * scaleFactor);
        box.group.setRotation(box.body.GetAngle());
        box.group.attrs.moved();
      }
      boxLayer.draw();
      lineLayer.draw();
      return world.ClearForces();
    };
    return animloop();
  };

}).call(this);
